<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heart Rate Logger</title>
    
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js and plugins via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>

    <style>
        /* Use the Inter font, which is clean and modern */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        html {
            font-family: 'Inter', sans-serif;
        }
        
        /* Ensure the app takes the full height and prevents bouncing */
        html, body {
            height: 100%;
            overflow: hidden;
        }

        /* Custom style for the large BPM text for performance */
        #bpmDisplay {
            font-weight: 900; /* Black weight */
            font-size: 6rem; /* Responsive large text */
            line-height: 1;
        }
        
        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            #bpmDisplay {
                font-size: 4rem;
            }
        }

        /* Helper class for button icons */
        .btn-icon {
            width: 2.5rem; /* 40px */
            height: 2.5rem; /* 40px */
        }
    </style>
</head>
<body class="flex flex-col h-full text-gray-100 overflow-hidden">

    <!-- Status Header (R1.2) -->
    <header class="bg-gray-800 shadow-md p-2 flex items-center justify-center flex-shrink-0">
        <span id="statusIndicator" class="w-3 h-3 rounded-full mr-2 bg-gray-500"></span>
        <span id="statusDisplay" class="text-sm font-semibold text-white">Idle</span>
        <span id="errorDisplay" class="text-sm text-red-400 ml-2"></span>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col p-4 overflow-y-auto space-y-4">
        
        <!-- Live BPM Display (R2.1) -->
        <div class="bg-gray-800 rounded-lg p-4 flex flex-row justify-center items-baseline">
            <span id="bpmDisplay" class="text-red-400">--</span>
            <span class="text-lg font-semibold text-gray-400 ml-2">BPM</span>
        </div>

        <!-- Stats Grid (R2.2, R2.3, R2.4, R2.5) -->
        <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <!-- Session Timer -->
            <div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-blue-300 text-sm">Session</span>
                <span id="sessionTimer" class="text-2xl font-bold">00:00:00</span>
            </div>
            <!-- Segment Timer -->
            <div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-blue-300 text-sm">Segment</span>
                <span id="segmentTimer" class="text-2xl font-bold">00:00:00</span>
            </div>
            <!-- Session Avg BPM -->
            <div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-green-300 text-sm">Session Avg</span>
                <span id="sessionAvgBpm" class="text-2xl font-bold">--</span>
            </div>
            <!-- Segment Avg BPM -->
            <div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-green-300 text-sm">Segment Avg</span>
                <span id="segmentAvgBpm" class="text-2xl font-bold">--</span>
            </div>
        </div>

        <!-- Live Chart (R4.1) -->
        <div class="flex-grow bg-gray-800 rounded-lg p-4 relative min-h-[200px] sm:min-h-[300px]">
            <canvas id="hrChart"></canvas>
        </div>
    </main>

    <!-- Controls (R3.1, R3.2, R3.3) -->
    <footer class="flex-shrink-0 grid grid-cols-4 gap-2 p-4 bg-gray-900 border-t border-gray-700">
        <!-- Start Button -->
        <button id="startButton" class="p-3 bg-green-600 text-white font-bold rounded-lg shadow-lg active:bg-green-700 disabled:opacity-50 flex justify-center items-center" aria-label="Start">
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.118v3.764a1 1 0 001.555.832l3.197-1.882a1 1 0 000-1.664l-3.197-1.882z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- Pause Button -->
        <button id="pauseButton" class="p-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg active:bg-blue-700 disabled:opacity-50 flex justify-center items-center" aria-label="Pause" disabled>
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- Mark Button -->
        <button id="markButton" class="p-3 bg-yellow-500 text-black font-bold rounded-lg shadow-lg active:bg-yellow-600 disabled:opacity-50 flex justify-center items-center" aria-label="Mark Segment" disabled>
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 6a3 3 0 013-3h10a1 1 0 01.8 1.6L14.25 8l2.55 3.4A1 1 0 0116 13H6a1 1 0 00-1 1v5a1 1 0 11-2 0V6z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- Stop Button -->
        <button id="stopButton" class="p-3 bg-red-600 text-white font-bold rounded-lg shadow-lg active:bg-red-700 disabled:opacity-50 flex justify-center items-center" aria-label="Stop" disabled>
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 6a2 2 0 00-2 2v4a2 2 0 002 2h4a2 2 0 002-2v-4a2 2 0 00-2-2H8z" clip-rule="evenodd"></path></svg>
        </button>
    </footer>

    <script>
        // --- 1. DOM Element References ---
        const statusIndicator = document.getElementById('statusIndicator');
        const statusDisplay = document.getElementById('statusDisplay');
        const errorDisplay = document.getElementById('errorDisplay');
        const bpmDisplay = document.getElementById('bpmDisplay');
        const sessionTimer = document.getElementById('sessionTimer');
        const segmentTimer = document.getElementById('segmentTimer');
        const sessionAvgBpm = document.getElementById('sessionAvgBpm');
        const segmentAvgBpm = document.getElementById('segmentAvgBpm');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const markButton = document.getElementById('markButton');
        const pauseButton = document.getElementById('pauseButton'); // NEW
        const chartCanvas = document.getElementById('hrChart');

        // --- 2. State Variables ---
        let bluetoothDevice = null;
        let hrCharacteristic = null;
        let chartInstance = null;
        
        let sessionReadings = [];
        let segmentReadings = [];
        
        let sessionStartTime = 0;
        let segmentStartTime = 0;
        
        // Timer state
        let sessionTimerInterval = null;
        let segmentTimerInterval = null;
        let maxSessionTimeout = null;
        let sessionElapsedMs = 0;
        let segmentElapsedMs = 0;
        
        let isPaused = false; // NEW: Pause state
        let wakeLock = null; // Wake Lock API

        // --- Constants ---
        const HR_SERVICE_UUID = 'heart_rate';
        const HR_CHARACTERISTIC_UUID = 'heart_rate_measurement';
        const MAX_SESSION_DURATION = 8 * 60 * 60 * 1000; // 8 hours (R3.4)
        const INITIAL_CHART_WINDOW_MS = 5 * 60 * 1000; // 5 minutes (R4.2)
        const CHART_Y_MAX_LEVELS = [160, 180, 200]; // Dynamic Y-axis levels

        // --- 3. UI and Helper Functions ---

        /**
         * (R1.2) Updates the status display with colored indicator.
         */
        function setStatus(status, error = '') {
            statusDisplay.textContent = status;
            errorDisplay.textContent = error;
            console.log(`Status: ${status} ${error ? `(Error: ${error})` : ''}`);

            statusIndicator.className = 'w-3 h-3 rounded-full mr-2'; // Reset classes
            if (error) {
                statusIndicator.classList.add('bg-red-500'); // Red
            } else if (status === 'Connected') {
                statusIndicator.classList.add('bg-green-500'); // Green
            } else if (status === 'Scanning...' || status === 'Connecting...') {
                statusIndicator.classList.add('bg-yellow-500'); // Yellow
            } else if (status === 'Paused') {
                statusIndicator.classList.add('bg-blue-500'); // Blue
            } else {
                statusIndicator.classList.add('bg-gray-500'); // Gray
            }
        }

        /**
         * Manages the enabled/disabled state of control buttons.
         */
        function updateButtonStates(isRecording, isPaused) {
            startButton.disabled = isRecording;
            stopButton.disabled = !isRecording;
            markButton.disabled = !isRecording || isPaused;
            pauseButton.disabled = !isRecording;
            
            // Toggle pause button icon and label
            if (isPaused) {
                pauseButton.innerHTML = `<svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.118v3.764a1 1 0 001.555.832l3.197-1.882a1 1 0 000-1.664l-3.197-1.882z" clip-rule="evenodd"></path></svg>`; // Play icon
                pauseButton.setAttribute('aria-label', 'Resume');
            } else {
                pauseButton.innerHTML = `<svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>`; // Pause icon
                pauseButton.setAttribute('aria-label', 'Pause');
            }
        }

        /**
         * Formats milliseconds into HH:MM:SS format.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        /**
         * Calculates and updates the average BPM displays.
         */
        function updateAverages() {
            if (sessionReadings.length > 0) {
                const sessionSum = sessionReadings.reduce((a, b) => a + b, 0);
                sessionAvgBpm.textContent = Math.round(sessionSum / sessionReadings.length);
            } else {
                sessionAvgBpm.textContent = '--';
            }
            
            if (segmentReadings.length > 0) {
                const segmentSum = segmentReadings.reduce((a, b) => a + b, 0);
                segmentAvgBpm.textContent = Math.round(segmentSum / segmentReadings.length);
            } else {
                segmentAvgBpm.textContent = '--';
            }
        }

        /**
         * Resets timers and average displays to their initial state.
         */
        function resetDisplays() {
            stopTimers();
            sessionTimer.textContent = '00:00:00';
            segmentTimer.textContent = '00:00:00';
            bpmDisplay.textContent = '--';
            sessionAvgBpm.textContent = '--';
            segmentAvgBpm.textContent = '--';
            sessionElapsedMs = 0;
            segmentElapsedMs = 0;
            isPaused = false;
            setStatus('Idle');
        }

        // --- 4. Timer Functions ---

        /**
         * (R2.2, R2.3) Starts the session and segment timers.
         */
        function startTimers() {
            sessionStartTime = Date.now() - sessionElapsedMs; // Account for resume
            segmentStartTime = Date.now() - segmentElapsedMs; // Account for resume
            
            isPaused = false;
            
            sessionTimerInterval = setInterval(() => {
                sessionElapsedMs = Date.now() - sessionStartTime;
                sessionTimer.textContent = formatTime(sessionElapsedMs);
            }, 1000);
            
            segmentTimerInterval = setInterval(() => {
                segmentElapsedMs = Date.now() - segmentStartTime;
                segmentTimer.textContent = formatTime(segmentElapsedMs);
            }, 1000);
        }

        /**
         * Stops all running timers.
         */
        function stopTimers() {
            clearInterval(sessionTimerInterval);
            clearInterval(segmentTimerInterval);
            sessionTimerInterval = null;
            segmentTimerInterval = null;
        }

        /**
         * Pauses all running timers.
         */
        function pauseTimers() {
            stopTimers();
            isPaused = true;
        }

        // --- 5. Charting Functions (R4.x) ---

        /**
         * Initializes the Chart.js instance.
         */
        function initChart() {
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            const ctx = chartCanvas.getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Heart Rate (BPM)',
                        data: [],
                        borderColor: 'rgb(248, 113, 113)', // red-400
                        backgroundColor: 'rgba(248, 113, 113, 0.2)',
                        borderWidth: 2,
                        tension: 0.1,
                        pointRadius: 0 
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Session Time (Minutes)'
                            },
                            ticks: {
                                color: 'rgb(209, 213, 219)' // gray-300
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            beginAtZero: true
                        },
                        y: {
                            // R2.1 (Modified) No Y-axis title
                            title: { display: false }, 
                            ticks: {
                                color: 'rgb(209, 213, 219)' // gray-300
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            // Dynamic Y-Axis: Start at 40-160
                            min: 40,
                            max: CHART_Y_MAX_LEVELS[0] // 160
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {}
                        }
                    }
                }
            });
        }
        
        /**
         * Adds a new data point to the chart.
         */
        function updateChartData(timestamp, bpm) {
            if (!chartInstance || isPaused) return; // Don't update chart if paused
            
            const elapsedMinutes = (timestamp - sessionStartTime) / 60000;
            
            chartInstance.data.datasets[0].data.push({ x: elapsedMinutes, y: bpm });
            
            // (R4.2) Dynamic X-Axis
            const sessionDurationMs = timestamp - sessionStartTime;
            let maxTime;
            let axesChanged = false; // Flag to track if we need to update

            if (sessionDurationMs <= INITIAL_CHART_WINDOW_MS) {
                maxTime = INITIAL_CHART_WINDOW_MS / 60000; // 5.0 minutes
            } else {
                maxTime = elapsedMinutes;
            }
            
            if (chartInstance.options.scales.x.max !== maxTime) {
                chartInstance.options.scales.x.min = 0;
                chartInstance.options.scales.x.max = maxTime;
                axesChanged = true;
            }

            // (R2.1 Modified) Dynamic Y-Axis
            const currentYMax = chartInstance.options.scales.y.max;
            if (bpm >= (currentYMax - 5)) { // If BPM is within 5 of the max
                let newMax = currentYMax;
                if (currentYMax < CHART_Y_MAX_LEVELS[1]) { // < 180
                    newMax = CHART_Y_MAX_LEVELS[1]; // Set to 180
                } else if (currentYMax < CHART_Y_MAX_LEVELS[2]) { // < 200
                    newMax = CHART_Y_MAX_LEVELS[2]; // Set to 200
                }
                
                if (newMax !== currentYMax) {
                    chartInstance.options.scales.y.max = newMax;
                    axesChanged = true;
                }
            }

            // *** FIX: Update chart every time ***
            chartInstance.update('none'); 
        }

        /**
         * (R4.3) Adds a vertical line to the chart at the current time.
         */
        function addSegmentMarker() {
            if (!chartInstance) return;
            
            const timestamp = Date.now();
            const elapsedMinutes = (timestamp - sessionStartTime) / 60000;
            const annotationName = `segment-${timestamp}`;
            
            chartInstance.options.plugins.annotation.annotations[annotationName] = {
                type: 'line',
                scaleID: 'x',
                value: elapsedMinutes,
                borderColor: 'rgb(234, 179, 8)', // yellow-500
                borderWidth: 2,
                borderDash: [6, 6],
                label: {
                    content: `Seg ${Object.keys(chartInstance.options.plugins.annotation.annotations).length + 1}`,
                    enabled: true,
                    position: 'start',
                    backgroundColor: 'rgba(234, 179, 8, 0.8)'
                }
            };
            
            chartInstance.update('none');
        }

        // --- 6. Core Logic Functions (R3.x) ---

        /**
         * (R3.1) Starts the recording session.
         */
        async function startRecording() {
            // BUGFIX: If we are in a weird state, disconnect first
            if (bluetoothDevice) {
                await bluetoothDevice.gatt.disconnect();
            }

            // 1. Reset state
            sessionReadings = [];
            segmentReadings = [];
            initChart(); // Re-initializes chart, including Y-axis
            resetDisplays();
            
            // 2. Update UI
            updateButtonStates(true, false);
            
            // 3. Start scanning
            if (!await connectToBLE()) {
                // Connection failed
                stopRecording(); // Reset UI back to idle
                return;
            }
            
            // 4. (R3.4) Set max session timeout
            clearTimeout(maxSessionTimeout);
            maxSessionTimeout = setTimeout(() => {
                console.log("Max session duration (8 hours) reached. Stopping.");
                setStatus("Stopped", "Max session (8h) reached");
                stopRecording();
            }, MAX_SESSION_DURATION);

            // 5. Request Wake Lock
            await requestWakeLock();
        }

        /**
         * (R3.2) Stops the recording session.
         */
        function stopRecording() {
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                bluetoothDevice.removeEventListener('gattserverdisconnected', onDeviceDisconnect);
                
                if (hrCharacteristic) {
                    hrCharacteristic.stopNotifications()
                        .catch(e => console.warn("Error stopping notifications (this is common on disconnect):", e.foo));
                    hrCharacteristic.removeEventListener('characteristicvaluechanged', handleHRData);
                    hrCharacteristic = null;
                }
                
                console.log("Disconnecting from device...");
                bluetoothDevice.gatt.disconnect();
            }
            
            bluetoothDevice = null;
            hrCharacteristic = null;
            
            stopTimers();
            clearTimeout(maxSessionTimeout);
            maxSessionTimeout = null;
            
            updateButtonStates(false, false);
            // Don't reset displays here, user might want to see final stats.
            if (statusDisplay.textContent !== 'Error') {
                setStatus('Idle');
            }
            
            releaseWakeLock();
            console.log("Session stopped.");
        }

        /**
         * (R3.3) Marks a new segment.
         */
        function markSegment() {
            if (isPaused) return; // Don't mark if paused

            console.log("Marking new segment...");
            addSegmentMarker();
            
            segmentStartTime = Date.now();
            segmentElapsedMs = 0; // Reset elapsed time
            segmentTimer.textContent = '00:00:00';
            
            segmentReadings = [];
            segmentAvgBpm.textContent = '--';
        }

        /**
         * Toggles the pause state of the session.
         */
        function togglePause() {
            if (isPaused) {
                // Resuming
                startTimers(); // Re-starts timers, sets isPaused = false
                updateButtonStates(true, false);
                setStatus('Connected');
            } else {
                // Pausing
                pauseTimers(); // Stops timers, sets isPaused = true
                updateButtonStates(true, true);
                setStatus('Paused');
            }
            console.log(`Session ${isPaused ? 'Paused' : 'Resumed'}`);
        }

        // --- 7. Web Bluetooth Functions (R1.x) ---

        /**
         * (R1.1) Scans for and connects to the BLE Heart Rate Monitor.
         */
        async function connectToBLE() {
            if (!navigator.bluetooth) {
                setStatus('Error', 'Web Bluetooth is not supported on this browser. Try Bluefy on iOS.');
                return false;
            }

            try {
                setStatus('Scanning...');
                
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [HR_SERVICE_UUID] }],
                    optionalServices: [HR_SERVICE_UUID]
                });
                
                setStatus('Connecting...');
                console.log(`Device found: ${bluetoothDevice.name}. Connecting to GATT server...`);
                
                bluetoothDevice.addEventListener('gattserverdisconnected', onDeviceDisconnect);
                
                const server = await bluetoothDevice.gatt.connect();
                console.log('GATT server connected, getting service...');
                
                const service = await server.getPrimaryService(HR_SERVICE_UUID);
                console.log('Service found, getting characteristic...');
                
                hrCharacteristic = await service.getCharacteristic(HR_CHARACTERISTIC_UUID);
                console.log('Characteristic found, starting notifications...');
                
                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);
                
                setStatus('Connected');
                console.log('Connected and receiving data!');
                
                // Start timers *after* successful connection
                startTimers();
                
                return true;

            } catch (error) {
                console.error("Bluetooth Connection Error:", error);
                if (error.name === 'NotFoundError') {
                    setStatus('Error', 'No device selected.');
                } else if (error.name === 'NotAllowedError') {
                    setStatus('Error', 'Bluetooth permission was denied.');
                } else {
                    setStatus('Error', 'Connection failed. (Is device in range?)');
                }
                return false;
            }
        }
        
        /**
         * (R1.4) Handles unexpected device disconnections.
         */
        function onDeviceDisconnect() {
            console.log("Device disconnected unexpectedly.");
            setStatus('Error', 'Device Disconnected');
            stopRecording();
        }

        /**
         * Handles incoming data from the HR characteristic.
         */
        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            
            const is16bit = flags & 0x01;
            const bpm = is16bit ? value.getUint16(1, true) : value.getUint8(1);
            
            const timestamp = Date.now();
            
            // (R2.1) Update live display
            bpmDisplay.textContent = bpm;
            
            if (isPaused) return; // If paused, only update BPM display, not stats

            sessionReadings.push(bpm);
            segmentReadings.push(bpm);
            
            updateAverages();
            updateChartData(timestamp, bpm);
        }

        // --- 8. Wake Lock Functions ---

        /**
         * Requests a screen wake lock.
         */
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock was released.');
                    });
                    console.log('Wake Lock is active.');
                } catch (err) {
                    console.error(`Wake Lock failed: ${err.name}, ${err.message}`);
                }
            } else {
                console.warn('Wake Lock API not supported.');
            }
        }

        /**
         * Releases the screen wake lock.
         */
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
                console.log('Wake Lock released.');
            }
        }
        
        // --- 9. Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initChart();
            updateButtonStates(false, false);
            
            if (!navigator.bluetooth) {
                setStatus('Error', 'Use Bluefy browser on iOS or Chrome on other platforms.');
            } else {
                setStatus('Idle');
            }

            startButton.addEventListener('click', startRecording);
            stopButton.addEventListener('click', stopRecording);
            markButton.addEventListener('click', markSegment);
            pauseButton.addEventListener('click', togglePause);

            // Handle visibility change to re-acquire wake lock if necessary
            document.addEventListener('visibilitychange', async () => {
                if (wakeLock !== null && document.visibilityState === 'visible') {
                    await requestWakeLock();
                }
            });
        });
    </script>
</body>
</html>