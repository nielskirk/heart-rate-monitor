<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heart Rate Logger</title>
    <!-- 1. Load Tailwind CSS for styling --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load Chart.js for data visualization --><script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    
    <!-- 3. Load Chart.js adapters for time-series axis --><script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    
    <!-- 4. Load Chart.js annotation plugin for segment markers --><script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>

    <style>
        /* Use the Inter font, which is clean and modern */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        html {
            font-family: 'Inter', sans-serif;
        }
        
        /* Ensure the app takes the full height and prevents bouncing */
        html, body {
            height: 100%;
            overflow: hidden;
        }

        /* Custom style for the large BPM text for performance */
        #bpmDisplay {
            font-weight: 900; /* Black weight */
            font-size: 7rem; /* Responsive large text */
            line-height: 1;
        }
        
        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            #bpmDisplay {
                font-size: 5rem;
            }
            .stat-grid {
                grid-template-columns: 1fr; /* Stack stats on small screens */
            }
        }
    </style>
</head>
<body class="flex flex-col h-full text-gray-100 overflow-hidden">

    <!-- New compact header for status --><header class="bg-gray-800 shadow-md p-2 flex items-center justify-center flex-shrink-0">
        <span id="statusIndicator" class="w-3 h-3 rounded-full mr-2"></span>
        <span id="statusDisplay" class="text-sm font-semibold text-white">Idle</span>
        <span id="errorDisplay" class="text-sm text-red-400 ml-2"></span>
    </header>

    <!-- Main Content Area --><main class="flex-grow flex flex-col p-4 overflow-y-auto space-y-4">
        
        <!-- Live BPM (R2.1) - Now takes full width as status is in header --><div class="bg-gray-800 rounded-lg p-6 flex flex-col justify-center items-center">
            <span id="bpmDisplay" class="text-red-400">--</span>
            <span class="text-lg font-semibold text-gray-400">BPM</span>
        </div>

        <!-- Timers and Averages (R2.2 - R2.5) --><div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <!-- Session Timer --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-blue-300 text-sm">Session</span>
                <span id="sessionTimer" class="text-2xl font-bold">00:00:00</span>
            </div>
            <!-- Segment Timer --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-blue-300 text-sm">Segment</span>
                <span id="segmentTimer" class="text-2xl font-bold">00:00:00</span>
            </div>
            <!-- Session Avg --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-green-300 text-sm">Session Avg</span>
                <span id="sessionAvgBpm" class="text-2xl font-bold">--</span>
            </div>
            <!-- Segment Avg --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-green-300 text-sm">Segment Avg</span>
                <span id="segmentAvgBpm" class="text-2xl font-bold">--</span>
            </div>
        </div>

        <!-- Chart (R4.1, R4.2, R4.3) --><div class="flex-grow bg-gray-800 rounded-lg p-4 relative min-h-[200px] sm:min-h-[300px]">
            <canvas id="hrChart"></canvas>
        </div>
    </main>

    <!-- Controls (R3.1, R3.2, R3.3) --><footer class="flex-shrink-0 grid grid-cols-3 gap-2 p-4 bg-gray-900 border-t border-gray-700">
        <button id="startButton" class="p-4 bg-blue-600 text-white font-bold rounded-lg shadow-lg active:bg-blue-700 disabled:opacity-50">
            Start
        </button>
        <button id="markButton" class="p-4 bg-yellow-500 text-black font-bold rounded-lg shadow-lg active:bg-yellow-600 disabled:opacity-50" disabled>
            Mark
        </button>
        <button id="stopButton" class="p-4 bg-red-600 text-white font-bold rounded-lg shadow-lg active:bg-red-700 disabled:opacity-50" disabled>
            Stop
        </button>
    </footer>

    <script>
        // --- 1. DOM Element References ---
        // Removed original statusDisplay and errorDisplay
        const statusIndicator = document.getElementById('statusIndicator'); // NEW
        const statusDisplay = document.getElementById('statusDisplay');
        const errorDisplay = document.getElementById('errorDisplay');

        const bpmDisplay = document.getElementById('bpmDisplay');
        const sessionTimer = document.getElementById('sessionTimer');
        const segmentTimer = document.getElementById('segmentTimer');
        const sessionAvgBpm = document.getElementById('sessionAvgBpm');
        const segmentAvgBpm = document.getElementById('segmentAvgBpm');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const markButton = document.getElementById('markButton');
        const chartCanvas = document.getElementById('hrChart');

        // --- 2. State Variables ---
        let bluetoothDevice = null;
        let hrCharacteristic = null;
        let chartInstance = null;
        
        let sessionReadings = [];
        let segmentReadings = [];
        
        let sessionStartTime = 0;
        let segmentStartTime = 0;
        
        let sessionTimerInterval = null;
        let segmentTimerInterval = null;
        let maxSessionTimeout = null;

        // --- Constants ---
        const HR_SERVICE_UUID = 'heart_rate';
        const HR_CHARACTERISTIC_UUID = 'heart_rate_measurement';
        const MAX_SESSION_DURATION = 8 * 60 * 60 * 1000; 
        const INITIAL_CHART_WINDOW = 5 * 60 * 1000;

        // --- 3. UI and Helper Functions ---

        /**
         * (R1.2) Updates the status display with colored indicator.
         * @param {string} status - The text to display (e.g., "Scanning...").
         * @param {string} [error=''] - Optional error message.
         */
        function setStatus(status, error = '') {
            statusDisplay.textContent = status;
            errorDisplay.textContent = error;
            console.log(`Status: ${status} ${error ? `(Error: ${error})` : ''}`);

            // Update indicator color based on status
            statusIndicator.className = 'w-3 h-3 rounded-full mr-2'; // Reset classes
            if (error) {
                statusIndicator.classList.add('bg-red-500'); // Red for error
            } else if (status === 'Connected') {
                statusIndicator.classList.add('bg-green-500'); // Green for connected
            } else if (status === 'Scanning...' || status === 'Connecting...') {
                statusIndicator.classList.add('bg-yellow-500'); // Yellow for active but not yet connected
            } else {
                statusIndicator.classList.add('bg-gray-500'); // Gray for idle
            }
        }

        /**
         * Manages the enabled/disabled state of control buttons.
         * @param {boolean} isRecording - Whether a session is active.
         */
        function updateButtonStates(isRecording) {
            startButton.disabled = isRecording;
            stopButton.disabled = !isRecording;
            markButton.disabled = !isRecording;
        }

        /**
         * Formats milliseconds into HH:MM:SS format.
         * @param {number} ms - Milliseconds elapsed.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        /**
         * Calculates and updates the average BPM displays.
         */
        function updateAverages() {
            if (sessionReadings.length > 0) {
                const sessionSum = sessionReadings.reduce((a, b) => a + b, 0);
                sessionAvgBpm.textContent = Math.round(sessionSum / sessionReadings.length);
            } else {
                sessionAvgBpm.textContent = '--';
            }
            
            if (segmentReadings.length > 0) {
                const segmentSum = segmentReadings.reduce((a, b) => a + b, 0);
                segmentAvgBpm.textContent = Math.round(segmentSum / segmentReadings.length);
            } else {
                segmentAvgBpm.textContent = '--';
            }
        }

        // --- 4. Timer Functions ---

        /**
         * (R2.2, R2.3) Starts the session and segment timers.
         */
        function startTimers() {
            sessionStartTime = Date.now();
            segmentStartTime = Date.now();
            
            sessionTimerInterval = setInterval(() => {
                const elapsed = Date.now() - sessionStartTime;
                sessionTimer.textContent = formatTime(elapsed);
            }, 1000);
            
            segmentTimerInterval = setInterval(() => {
                const elapsed = Date.now() - segmentStartTime;
                segmentTimer.textContent = formatTime(elapsed);
            }, 1000);
        }

        /**
         * Stops all running timers.
         */
        function stopTimers() {
            clearInterval(sessionTimerInterval);
            clearInterval(segmentTimerInterval);
            sessionTimerInterval = null;
            segmentTimerInterval = null;
        }
        
        /**
         * Resets timers and average displays to their initial state.
         */
        function resetDisplays() {
            stopTimers();
            sessionTimer.textContent = '00:00:00';
            segmentTimer.textContent = '00:00:00';
            bpmDisplay.textContent = '--';
            sessionAvgBpm.textContent = '--';
            segmentAvgBpm.textContent = '--';
            setStatus('Idle');
        }

        // --- 5. Charting Functions (R4.x) ---

        /**
         * Initializes the Chart.js instance.
         */
        function initChart() {
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            const ctx = chartCanvas.getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Heart Rate (BPM)',
                        data: [], // Data points: {x: timestamp, y: bpm}
                        borderColor: 'rgb(248, 113, 113)', // red-400
                        backgroundColor: 'rgba(248, 113, 113, 0.2)',
                        borderWidth: 2,
                        tension: 0.1,
                        pointRadius: 0 // No dots on data points
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear', // CHANGED: from 'time' to 'linear'
                            // REMOVED: All 'time' specific options
                            title: {
                                display: true,
                                text: 'Session Time (Minutes)' // CHANGED: Updated title
                            },
                            ticks: {
                                color: 'rgb(209, 213, 219)' // gray-300
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            beginAtZero: true // ADDED: Ensure axis starts at 0
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'BPM'
                            },
                            ticks: {
                                color: 'rgb(209, 213, 219)' // gray-300
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            suggestedMin: 40,
                            suggestedMax: 200
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        annotation: {
                            annotations: {} // We will add segment lines here
                        }
                    }
                }
            });
            // Register the annotation plugin
            // Chart.register(ChartjsPluginAnnotation); // <--- REMOVE THIS LINE
        }
        
        /**
         * Adds a new data point to the chart.
         * @param {number} timestamp - The time of the reading.
         * @param {number} bpm - The heart rate value.
         */
        function updateChartData(timestamp, bpm) {
            if (!chartInstance) return;
            
            const elapsedMinutes = (timestamp - sessionStartTime) / 60000; // 60 * 1000
            
            chartInstance.data.datasets[0].data.push({ x: elapsedMinutes, y: bpm });
            
            // (R4.2) Dynamic X-Axis
            const sessionDurationMs = timestamp - sessionStartTime;
            let minTime = 0; // CHANGED: Always start at 0
            let maxTime;

            if (sessionDurationMs <= INITIAL_CHART_WINDOW) {
                // In the first 5 minutes, show a fixed 5-minute window
                maxTime = INITIAL_CHART_WINDOW / 60000; // 5.0 minutes
            } else {
                // After 5 minutes, "zoom out" to show the entire session
                maxTime = elapsedMinutes; // Use elapsed minutes
            }
            
            chartInstance.options.scales.x.min = minTime;
            chartInstance.options.scales.x.max = maxTime;

            chartInstance.update('none'); // 'none' for no animation
        }

        /**
         * (R4.3) Adds a vertical line to the chart at the current time.
         */
        function addSegmentMarker() {
            if (!chartInstance) return;
            
            const timestamp = Date.now();
            const elapsedMinutes = (timestamp - sessionStartTime) / 60000; // Calculate elapsed minutes
            const annotationName = `segment-${timestamp}`;
            
            chartInstance.options.plugins.annotation.annotations[annotationName] = {
                type: 'line',
                scaleID: 'x',
                value: elapsedMinutes, // CHANGED: Use elapsed minutes instead of timestamp
                borderColor: 'rgb(234, 179, 8)', // yellow-500
                borderWidth: 2,
                borderDash: [6, 6], // Dashed line
                label: {
                    content: `Seg ${Object.keys(chartInstance.options.plugins.annotation.annotations).length + 1}`,
                    enabled: true,
                    position: 'start',
                    backgroundColor: 'rgba(234, 179, 8, 0.8)'
                }
            };
            
            chartInstance.update('none');
        }

        // --- 6. Core Logic Functions (R3.x) ---

        /**
         * (R3.1) Starts the recording session.
         */
        async function startRecording() {
            // 1. Reset state
            sessionReadings = [];
            segmentReadings = [];
            if (chartInstance) {
                chartInstance.data.datasets[0].data = [];
                chartInstance.options.plugins.annotation.annotations = {};
                chartInstance.update('none');
            }
            resetDisplays();
            
            // 2. Update UI
            updateButtonStates(true);
            
            // 3. Start scanning
            if (!await connectToBLE()) {
                // Connection failed (e.g., timeout, user cancel)
                stopRecording(); // Reset UI back to idle
                return;
            }
            
            // 4. (R3.4) Set max session timeout
            clearTimeout(maxSessionTimeout);
            maxSessionTimeout = setTimeout(() => {
                console.log("Max session duration (8 hours) reached. Stopping.");
                setStatus("Stopped", "Max session (8h) reached");
                stopRecording();
            }, MAX_SESSION_DURATION);
        }

        /**
         * (R3.2) Stops the recording session.
         */
        function stopRecording() {
            if (bluetoothDevice) {
                // Remove the listener *first* to prevent onDeviceDisconnect from firing
                // if this was a user-initiated stop.
                bluetoothDevice.removeEventListener('gattserverdisconnected', onDeviceDisconnect);
                
                if (bluetoothDevice.gatt.connected) {
                    console.log("Disconnecting from device...");
                    
                    // Clean up resources *before* disconnecting
                    if (hrCharacteristic) {
                        hrCharacteristic.stopNotifications()
                            .catch(e => console.warn("Error stopping notifications (this is common on disconnect):", e)); // Just warn, not critical
                        hrCharacteristic.removeEventListener('characteristicvaluechanged', handleHRData);
                        hrCharacteristic = null;
                    }
                    
                    bluetoothDevice.gatt.disconnect();
                }
            }
            
            // Null out vars regardless
            bluetoothDevice = null;
            hrCharacteristic = null; // Be sure
            
            stopTimers();
            clearTimeout(maxSessionTimeout);
            maxSessionTimeout = null;
            
            updateButtonStates(false);
            // Don't reset displays here, user might want to see final stats.
            // Only set status if it's not already an error.
            if (statusDisplay.textContent !== 'Error') {
                setStatus('Idle');
            }
            console.log("Session stopped.");
        }

        /**
         * (R3.3) Marks a new segment.
         */
        function markSegment() {
            console.log("Marking new segment...");
            
            // 1. Add visual marker to chart
            addSegmentMarker();
            
            // 2. Reset segment timer
            segmentStartTime = Date.now();
            segmentTimer.textContent = '00:00:00';
            
            // 3. Reset segment average
            segmentReadings = [];
            segmentAvgBpm.textContent = '--';
        }

        // --- 7. Web Bluetooth Functions (R1.x) ---

        /**
         * (R1.1) Scans for and connects to the BLE Heart Rate Monitor.
         * @returns {Promise<boolean>} True on success, false on failure.
         */
        async function connectToBLE() {
            if (!navigator.bluetooth) {
                setStatus('Error', 'Web Bluetooth is not supported on this browser. Try Bluefy on iOS.');
                return false;
            }

            try {
                setStatus('Scanning...');
                
                // (R1.3) We will now scan by SERVICE, which is more robust.
                // The browser will show a picker list of all nearby Heart Rate devices.
                // The scan "timeout" is effectively the user pressing "Cancel" on the picker.
                
                console.log(`Scanning for devices with the Heart Rate service...`);
                
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [
                        // R1.1 (Modified): Filter for the Heart Rate service, not a specific name.
                        { services: [HR_SERVICE_UUID] }
                    ],
                    optionalServices: [HR_SERVICE_UUID] // We still need to request the service
                });
                
                setStatus('Connecting...');
                console.log(`Device found: ${bluetoothDevice.name}. Connecting to GATT server...`);
                
                // (R1.4) Add disconnect listener
                bluetoothDevice.addEventListener('gattserverdisconnected', onDeviceDisconnect);
                
                const server = await bluetoothDevice.gatt.connect();
                console.log('GATT server connected, getting service...');
                
                const service = await server.getPrimaryService(HR_SERVICE_UUID);
                console.log('Service found, getting characteristic...');
                
                hrCharacteristic = await service.getCharacteristic(HR_CHARACTERISTIC_UUID);
                console.log('Characteristic found, starting notifications...');
                
                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);
                
                setStatus('Connected');
                console.log('Connected and receiving data!');
                
                // Start timers *after* successful connection
                startTimers();
                
                return true;

            } catch (error) {
                console.error("Bluetooth Connection Error:", error);
                if (error.name === 'NotFoundError') {
                    // This error now means the user cancelled the picker
                    setStatus('Error', 'No device selected.');
                } else if (error.name === 'NotAllowedError') {
                    setStatus('Error', 'Bluetooth permission was denied.');
                } else {
                    setStatus('Error', error.message);
                }
                return false;
            }
        }
        
        /**
         * (R1.4) Handles unexpected device disconnections.
         */
        function onDeviceDisconnect() {
            console.log("Device disconnected unexpectedly.");
            setStatus('Error', 'Device Disconnected');
            stopRecording(); // Call stopRecording to clean up UI and state
        }

        /**
         * Handles incoming data from the HR characteristic.
         * @param {Event} event - The 'characteristicvaluechanged' event.
         */
        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            
            // Check if BPM is 8-bit or 16-bit
            const is16bit = flags & 0x01;
            const bpm = is16bit ? value.getUint16(1, true) : value.getUint8(1);
            
            const timestamp = Date.now();
            
            // (R2.1) Update live display
            bpmDisplay.textContent = bpm;
            
            // Update data arrays
            sessionReadings.push(bpm);
            segmentReadings.push(bpm);
            
            // (R2.4, R2.5) Update averages
            updateAverages();
            
            // (R4.1) Update chart
            updateChartData(timestamp, bpm);
        }

        // --- 8. Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initChart();
            updateButtonStates(false);
            
            // Add initial message for Web Bluetooth
            if (!navigator.bluetooth) {
                setStatus('Error', 'Use Bluefy browser on iOS or Chrome on other platforms.');
            } else {
                setStatus('Idle');
            }

            startButton.addEventListener('click', startRecording);
            stopButton.addEventListener('click', stopRecording);
            markButton.addEventListener('click', markSegment);
        });
    </script>
</body>
</html>