<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heart Rate Logger</title>
    <!-- 1. Load Tailwind CSS for styling --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load Chart.js for data visualization --><script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    
    <!-- 3. Load Chart.js adapters for time-series axis --><script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    
    <!-- 4. Load Chart.js annotation plugin for segment markers --><script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>

    <style>
        /* Use the Inter font, which is clean and modern */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        html {
            font-family: 'Inter', sans-serif;
        }
        
        /* Ensure the app takes the full height and prevents bouncing */
        html, body {
            height: 100%;
            overflow: hidden;
        }

        /* Custom style for the large BPM text for performance */
        #bpmDisplay {
            font-weight: 900; /* Black weight */
            font-size: 6rem; /* Responsive large text (was 7rem) */
            line-height: 1;
        }
        
        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            #bpmDisplay {
                font-size: 4rem; /* (was 5rem) */
            }
            .stat-grid {
                grid-template-columns: 1fr; /* Stack stats on small screens */
            }
        }

        /* Helper class for button icons */
        .btn-icon {
            width: 2rem; /* 32px - (was 1.5rem) */
            height: 2rem; /* 32px - (was 1.5rem) */
        }
    </style>
</head>
<body class="flex flex-col h-full text-gray-100 overflow-hidden">

    <!-- New compact header for status --><header class="bg-gray-800 shadow-md p-2 flex items-center justify-center flex-shrink-0">
        <span id="statusIndicator" class="w-3 h-3 rounded-full mr-2"></span>
        <span id="statusDisplay" class="text-sm font-semibold text-white">Idle</span>
        <span id="errorDisplay" class="text-sm text-red-400 ml-2"></span>
    </header>

    <!-- Main Content Area --><main class="flex-grow flex flex-col p-4 overflow-y-auto space-y-4">
        
        <!-- Live BPM (R2.1) - Now takes full width as status is in header --><div class="bg-gray-800 rounded-lg p-4 flex flex-row justify-center items-baseline">
            <span id="bpmDisplay" class="text-red-400">--</span>
            <span class="text-xl font-semibold text-gray-400 ml-3">BPM</span>
        </div>

        <!-- Timers and Averages (R2.2 - R2.5) --><div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <!-- Session Timer --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-blue-300 text-sm">Session</span>
                <span id="sessionTimer" class="text-2xl font-bold">00:00:00</span>
            </div>
            <!-- Segment Timer --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-blue-300 text-sm">Segment</span>
                <span id="segmentTimer" class="text-2xl font-bold">00:00:00</span>
            </div>
            <!-- Session Avg --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-green-300 text-sm">Session Avg</span>
                <span id="sessionAvgBpm" class="text-2xl font-bold">--</span>
            </div>
            <!-- Segment Avg --><div class="bg-gray-800 rounded-lg p-4 flex flex-col items-center">
                <span class="font-semibold text-green-300 text-sm">Segment Avg</span>
                <span id="segmentAvgBpm" class="text-2xl font-bold">--</span>
            </div>
        </div>

        <!-- Chart (R4.1, R4.2, R4.3) --><div class="flex-grow bg-gray-800 rounded-lg p-4 relative min-h-[200px] sm:min-h-[300px]">
            <canvas id="hrChart"></canvas>
        </div>
    </main>

    <!-- Controls (R3.1, R3.2, R3.3) --><footer class="flex-shrink-0 grid grid-cols-4 gap-2 p-4 bg-gray-900 border-t border-gray-700">
        <!-- Start Button --><button id="startButton" class="p-4 bg-green-600 text-white font-bold rounded-lg shadow-lg active:bg-green-700 disabled:opacity-50 flex justify-center items-center" aria-label="Start">
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.118v3.764a1 1 0 001.555.832l3.197-1.882a1 1 0 000-1.664l-3.197-1.882z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- Pause Button --><button id="pauseButton" class="p-4 bg-blue-600 text-white font-bold rounded-lg shadow-lg active:bg-blue-700 disabled:opacity-50 flex justify-center items-center" aria-label="Pause" disabled>
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- Mark Button --><button id="markButton" class="p-4 bg-yellow-500 text-black font-bold rounded-lg shadow-lg active:bg-yellow-600 disabled:opacity-50 flex justify-center items-center" aria-label="Mark Segment" disabled>
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 6a3 3 0 013-3h10a1 1 0 01.8 1.6L14.25 8l2.55 3.4A1 1 0 0116 13H6a1 1 0 00-1 1v5a1 1 0 11-2 0V6z" clip-rule="evenodd"></path></svg>
        </button>
        <!-- Stop Button --><button id="stopButton" class="p-4 bg-red-600 text-white font-bold rounded-lg shadow-lg active:bg-red-700 disabled:opacity-50 flex justify-center items-center" aria-label="Stop" disabled>
            <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 9a1 1 0 00-1 1v2a1 1 0 102 0v-2a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v2a1 1 0 102 0v-2a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
        </button>
    </footer>

    <script>
        // --- 1. DOM Element References ---
        const statusIndicator = document.getElementById('statusIndicator');
        const statusDisplay = document.getElementById('statusDisplay');
        const errorDisplay = document.getElementById('errorDisplay');

        const bpmDisplay = document.getElementById('bpmDisplay');
        const sessionTimer = document.getElementById('sessionTimer');
        const segmentTimer = document.getElementById('segmentTimer');
        const sessionAvgBpm = document.getElementById('sessionAvgBpm');
        const segmentAvgBpm = document.getElementById('segmentAvgBpm');
        
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton'); // NEW
        const markButton = document.getElementById('markButton');
        const stopButton = document.getElementById('stopButton');
        
        const chartCanvas = document.getElementById('hrChart');

        // --- 2. State Variables ---
        let bluetoothDevice = null;
        let hrCharacteristic = null;
        let chartInstance = null;
        
        let sessionReadings = [];
        let segmentReadings = [];
        
        let sessionStartTime = 0;
        let segmentStartTime = 0;
        let sessionElapsedTime = 0; // NEW: Store elapsed ms when paused
        let segmentElapsedTime = 0; // NEW
        
        let sessionTimerInterval = null;
        let segmentTimerInterval = null;
        let maxSessionTimeout = null;
        let wakeLock = null; 
        let isPaused = false; // NEW

        // --- Constants ---
        const HR_SERVICE_UUID = 'heart_rate';
        const HR_CHARACTERISTIC_UUID = 'heart_rate_measurement';
        const MAX_SESSION_DURATION = 8 * 60 * 60 * 1000; 
        const INITIAL_CHART_WINDOW = 5 * 60 * 1000;

        // --- 3. UI and Helper Functions ---

        /**
         * (R1.2) Updates the status display with colored indicator.
         */
        function setStatus(status, error = '') {
            // Don't overwrite Paused status unless it's an error
            if (isPaused && status === 'Connected' && !error) {
                statusDisplay.textContent = 'Paused';
                return;
            }
            statusDisplay.textContent = status;
            errorDisplay.textContent = error;
            console.log(`Status: ${status} ${error ? `(Error: ${error})` : ''}`);

            // Update indicator color based on status
            statusIndicator.className = 'w-3 h-3 rounded-full mr-2'; // Reset classes
            if (error) {
                statusIndicator.classList.add('bg-red-500'); // Red for error
            } else if (status === 'Connected') {
                statusIndicator.classList.add('bg-green-500'); // Green for connected
            } else if (status === 'Paused') {
                statusIndicator.classList.add('bg-yellow-500'); // Yellow for paused
            } else if (status === 'Scanning...' || status === 'Connecting...') {
                statusIndicator.classList.add('bg-yellow-500'); // Yellow for active
            } else {
                statusIndicator.classList.add('bg-gray-500'); // Gray for idle
            }
        }

        /**
         * Manages the enabled/disabled state of control buttons.
         */
        function updateButtonStates(isRecording) {
            startButton.disabled = isRecording;
            stopButton.disabled = !isRecording;
            markButton.disabled = !isRecording;
            pauseButton.disabled = !isRecording; // NEW
        }

        /**
         * Formats milliseconds into HH:MM:SS format.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        /**
         * Calculates and updates the average BPM displays.
         */
        function updateAverages() {
            if (sessionReadings.length > 0) {
                const sessionSum = sessionReadings.reduce((a, b) => a + b, 0);
                sessionAvgBpm.textContent = Math.round(sessionSum / sessionReadings.length);
            } else {
                sessionAvgBpm.textContent = '--';
            }
            
            if (segmentReadings.length > 0) {
                const segmentSum = segmentReadings.reduce((a, b) => a + b, 0);
                segmentAvgBpm.textContent = Math.round(segmentSum / segmentReadings.length);
            } else {
                segmentAvgBpm.textContent = '--';
            }
        }

        // --- 4. Timer Functions ---

        /**
         * (R2.2, R2.3) Starts or resumes the session and segment timers.
         */
        function startTimers() {
            // We are starting/resuming
            sessionStartTime = Date.now() - sessionElapsedTime; // Offset by previously elapsed time
            segmentStartTime = Date.now() - segmentElapsedTime;
            
            sessionTimerInterval = setInterval(() => {
                sessionElapsedTime = Date.now() - sessionStartTime;
                sessionTimer.textContent = formatTime(sessionElapsedTime);
            }, 1000);
            
            segmentTimerInterval = setInterval(() => {
                segmentElapsedTime = Date.now() - segmentStartTime;
                segmentTimer.textContent = formatTime(segmentElapsedTime);
            }, 1000);
        }

        /**
         * Stops (pauses) all running timers.
         */
        function stopTimers() {
            // This is now a "pause" function
            // The elapsed time variables hold the last value
            clearInterval(sessionTimerInterval);
            clearInterval(segmentTimerInterval);
            sessionTimerInterval = null;
            segmentTimerInterval = null;
        }
        
        /**
         * Resets timers and average displays to their initial state.
         */
        function resetDisplays() {
            stopTimers();
            sessionElapsedTime = 0; // Reset elapsed time
            segmentElapsedTime = 0; // Reset elapsed time
            sessionTimer.textContent = '00:00:00';
            segmentTimer.textContent = '00:00:00';
            bpmDisplay.textContent = '--';
            sessionAvgBpm.textContent = '--';
            segmentAvgBpm.textContent = '--';
            setStatus('Idle');
        }

        // --- 5. Charting Functions (R4.x) ---

        /**
         * Initializes the Chart.js instance.
         */
        function initChart() {
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            const ctx = chartCanvas.getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Heart Rate (BPM)',
                        data: [], // Data points: {x: timestamp, y: bpm}
                        borderColor: 'rgb(248, 113, 113)', // red-400
                        backgroundColor: 'rgba(248, 113, 113, 0.2)',
                        borderWidth: 2,
                        tension: 0.1,
                        pointRadius: 0 // No dots on data points
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Session Time (Minutes)'
                            },
                            ticks: {
                                color: 'rgb(209, 213, 219)' // gray-300
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            beginAtZero: true
                        },
                        y: {
                            title: {
                                display: false, // Per user request
                            },
                            ticks: {
                                color: 'rgb(209, 213, 219)' // gray-300
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            // NEW: Set hard min/max per user request
                            min: 40,
                            max: 160
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        annotation: {
                            annotations: {} // We will add segment lines here
                        }
                    }
                }
            });
        }
        
        /**
         * Adds a new data point to the chart.
         */
        function updateChartData(timestamp, bpm) {
            if (!chartInstance) return;
            
            // --- NEW: Dynamic Y-Axis Logic ---
            const currentMax = chartInstance.options.scales.y.max;
            let newMax = currentMax;

            if (bpm >= 175 && currentMax < 200) {
                newMax = 200;
            } else if (bpm >= 155 && currentMax < 180) {
                newMax = 180;
            }
            
            let chartNeedsUpdate = (newMax !== currentMax);
            if (chartNeedsUpdate) {
                chartInstance.options.scales.y.max = newMax;
            }
            // --- End Dynamic Y-Axis ---

            const elapsedMinutes = (timestamp - sessionStartTime) / 60000; // 60 * 1000
            
            chartInstance.data.datasets[0].data.push({ x: elapsedMinutes, y: bpm });
            
            // (R4.2) Dynamic X-Axis
            const sessionDurationMs = timestamp - sessionStartTime;
            let minTime = 0; 
            let maxTime;

            if (sessionDurationMs <= INITIAL_CHART_WINDOW) {
                maxTime = INITIAL_CHART_WINDOW / 60000; // 5.0 minutes
            } else {
                maxTime = elapsedMinutes; // Use elapsed minutes
            }
            
            if (chartInstance.options.scales.x.max !== maxTime) {
                chartInstance.options.scales.x.min = minTime;
                chartInstance.options.scales.x.max = maxTime;
                chartNeedsUpdate = true;
            }

            if (chartNeedsUpdate) {
                chartInstance.update('none'); // 'none' for no animation
            }
        }

        /**
         * (R4.3) Adds a vertical line to the chart at the current time.
         */
        function addSegmentMarker() {
            if (!chartInstance) return;
            
            const timestamp = Date.now();
            const elapsedMinutes = (timestamp - sessionStartTime) / 60000; 
            const annotationName = `segment-${timestamp}`;
            
            chartInstance.options.plugins.annotation.annotations[annotationName] = {
                type: 'line',
                scaleID: 'x',
                value: elapsedMinutes, 
                borderColor: 'rgb(234, 179, 8)', // yellow-500
                borderWidth: 2,
                borderDash: [6, 6], // Dashed line
                label: {
                    content: `Seg ${Object.keys(chartInstance.options.plugins.annotation.annotations).length + 1}`,
                    enabled: true,
                    position: 'start',
                    backgroundColor: 'rgba(234, 179, 8, 0.8)'
                }
            };
            
            chartInstance.update('none');
        }

        // --- 6. Core Logic Functions (R3.x) ---

        /**
         * (R3.1) Starts the recording session.
         */
        async function startRecording() {
            // --- BUGFIX: Clean up any previous state ---
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                console.log("Found lingering connection. Disconnecting before start...");
                bluetoothDevice.gatt.disconnect(); // This will trigger onDeviceDisconnect
            }
            bluetoothDevice = null;
            hrCharacteristic = null;
            isPaused = false; // Reset pause state
            
            // 1. Reset state
            sessionReadings = [];
            segmentReadings = [];
            if (chartInstance) {
                chartInstance.data.datasets[0].data = [];
                chartInstance.options.plugins.annotation.annotations = {};
                // Reset Y-Axis to default
                chartInstance.options.scales.y.min = 40;
                chartInstance.options.scales.y.max = 160;
                chartInstance.update('none');
            }
            resetDisplays(); // Resets timers and elapsed time
            
            // 2. Update UI
            updateButtonStates(true);
            pauseButton.innerHTML = `<svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>`;
            pauseButton.classList.remove('bg-yellow-500');
            pauseButton.classList.add('bg-blue-600');
            
            // 3. Request Screen Wake Lock
            await requestWakeLock();

            // 4. Start scanning
            if (!await connectToBLE()) {
                // Connection failed (e.g., timeout, user cancel)
                stopRecording(); // Reset UI back to idle
                return;
            }
            
            // 5. (R3.4) Set max session timeout
            clearTimeout(maxSessionTimeout);
            maxSessionTimeout = setTimeout(() => {
                console.log("Max session duration (8 hours) reached. Stopping.");
                setStatus("Stopped", "Max session (8h) reached");
                stopRecording();
            }, MAX_SESSION_DURATION);
        }

        /**
         * (R3.2) Stops the recording session.
         */
        async function stopRecording() {
            if (bluetoothDevice) {
                bluetoothDevice.removeEventListener('gattserverdisconnected', onDeviceDisconnect);
                if (bluetoothDevice.gatt.connected) {
                    console.log("Disconnecting from device...");
                    if (hrCharacteristic) {
                        hrCharacteristic.stopNotifications()
                            .catch(e => console.warn("Error stopping notifications:", e)); 
                        hrCharacteristic.removeEventListener('characteristicvaluechanged', handleHRData);
                        hrCharacteristic = null;
                    }
                    bluetoothDevice.gatt.disconnect();
                }
            }
            
            // Null out vars regardless
            bluetoothDevice = null;
            hrCharacteristic = null; 
            
            stopTimers();
            clearTimeout(maxSessionTimeout);
            maxSessionTimeout = null;
            isPaused = false; // Reset pause state
            
            releaseWakeLock();

            updateButtonStates(false);
            if (statusDisplay.textContent !== 'Error') {
                setStatus('Idle');
            }
            
            // Reset pause button to default state
            pauseButton.innerHTML = `<svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>`;
            pauseButton.classList.remove('bg-yellow-500');
            pauseButton.classList.add('bg-blue-600');
            
            console.log("Session stopped.");
        }

        /**
         * (R3.3) Marks a new segment.
         */
        function markSegment() {
            console.log("Marking new segment...");
            
            addSegmentMarker();
            
            // 2. Reset segment timer
            segmentStartTime = Date.now();
            segmentElapsedTime = 0; // Reset segment elapsed time
            segmentTimer.textContent = '00:00:00';
            
            // 3. Reset segment average
            segmentReadings = [];
            segmentAvgBpm.textContent = '--';
        }

        /**
         * NEW: Toggles the paused state of the session.
         */
        function togglePause() {
            if (!isPaused) {
                // --- PAUSING ---
                isPaused = true;
                stopTimers(); // Freezes the timers and stores elapsed time
                pauseButton.innerHTML = `
                    <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.118v3.764a1 1 0 001.555.832l3.197-1.882a1 1 0 000-1.664l-3.197-1.882z" clip-rule="evenodd"></path></svg>
                    <span class="sr-only">Resume</span>`;
                pauseButton.classList.replace('bg-blue-600', 'bg-yellow-500');
                markButton.disabled = true; // Can't mark when paused
                setStatus('Paused');
            } else {
                // --- RESUMING ---
                isPaused = false;
                startTimers(); // Resumes timers from where they left off
                pauseButton.innerHTML = `
                    <svg class="btn-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                    <span class="sr-only">Pause</span>`;
                pauseButton.classList.replace('bg-yellow-500', 'bg-blue-600');
                markButton.disabled = false;
                setStatus('Connected'); // Go back to "Connected" status
            }
        }

        // --- 7. Web Bluetooth Functions (R1.x) ---

        /**
         * (R1.1) Scans for and connects to the BLE Heart Rate Monitor.
         */
        async function connectToBLE() {
            if (!navigator.bluetooth) {
                setStatus('Error', 'Web Bluetooth is not supported on this browser. Try Bluefy on iOS.');
                return false;
            }

            try {
                setStatus('Scanning...');
                
                console.log(`Scanning for devices with the Heart Rate service...`);
                
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [ { services: [HR_SERVICE_UUID] } ],
                    optionalServices: [HR_SERVICE_UUID] 
                });
                
                setStatus('Connecting...');
                console.log(`Device found: ${bluetoothDevice.name}. Connecting to GATT server...`);
                
                bluetoothDevice.addEventListener('gattserverdisconnected', onDeviceDisconnect);
                
                const server = await bluetoothDevice.gatt.connect();
                console.log('GATT server connected, getting service...');
                
                const service = await server.getPrimaryService(HR_SERVICE_UUID);
                console.log('Service found, getting characteristic...');
                
                hrCharacteristic = await service.getCharacteristic(HR_CHARACTERISTIC_UUID);
                console.log('Characteristic found, starting notifications...');
                
                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);
                
                setStatus('Connected');
                console.log('Connected and receiving data!');
                
                // Start timers *after* successful connection
                startTimers();
                
                return true;

            } catch (error) {
                console.error("Bluetooth Connection Error:", error);
                if (error.name === 'NotFoundError') {
                    setStatus('Error', 'No device selected.');
                } else if (error.name === 'NotAllowedError') {
                    setStatus('Error', 'Bluetooth permission was denied.');
                } else {
                    setStatus('Error', error.message);
                }
                return false;
            }
        }
        
        /**
         * (R1.4) Handles unexpected device disconnections.
         */
        function onDeviceDisconnect() {
            console.log("Device disconnected unexpectedly.");
            setStatus('Error', 'Device Disconnected');
            stopRecording(); // Call stopRecording to clean up UI and state
        }

        /**
         * Handles incoming data from the HR characteristic.
         */
        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            
            const is16bit = flags & 0x01;
            const bpm = is16bit ? value.getUint16(1, true) : value.getUint8(1);
            
            const timestamp = Date.now();
            
            // (R2.1) Update live display (ALWAYS)
            bpmDisplay.textContent = bpm;
            
            // --- NEW: Check if paused ---
            if (isPaused) return; 
            
            // --- From this point, we are NOT paused ---
            
            // Update data arrays
            sessionReadings.push(bpm);
            segmentReadings.push(bpm);
            
            // (R2.4, R2.5) Update averages
            updateAverages();
            
            // (R4.1) Update chart
            updateChartData(timestamp, bpm);
        }

        // --- 8. Wake Lock Functions ---

        /**
         * Requests a screen wake lock to keep the device from sleeping.
         */
        async function requestWakeLock() {
            if ('wakeLock' in navigator && !wakeLock) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Screen Wake Lock was released');
                        wakeLock = null; // Set to null so it can be re-acquired
                    });
                    console.log('Screen Wake Lock acquired');
                } catch (err) {
                    console.error(`Wake Lock Error: ${err.name}: ${err.message}`);
                }
            } else {
                console.log('Wake Lock API not supported or lock already held.');
            }
        }

        /**
         * Releases the screen wake lock.
         */
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
                console.log('Screen Wake Lock released');
            }
        }

        // --- 9. Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initChart();
            updateButtonStates(false);
            
            if (!navigator.bluetooth) {
                setStatus('Error', 'Use Bluefy browser on iOS or Chrome on other platforms.');
            } else {
                setStatus('Idle');
            }

            startButton.addEventListener('click', startRecording);
            stopButton.addEventListener('click', stopRecording);
            markButton.addEventListener('click', markSegment);
            pauseButton.addEventListener('click', togglePause); // NEW

            // Add listener to re-acquire wake lock if tab becomes visible
            document.addEventListener('visibilitychange', async () => {
                if (wakeLock === null && document.visibilityState === 'visible' && startButton.disabled) {
                    // We are in a session (startButton is disabled) and the lock was released
                    console.log('Re-acquiring wake lock on visibility change');
                    await requestWakeLock();
                }
            });
        });
    </script>
</body>
</html>